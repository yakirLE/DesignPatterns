// Autogenerated code. Do not modify.
package com.yakir.design.patterns.builder.functional.tp;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.function.IntUnaryOperator;
import java.util.function.UnaryOperator;
import java.util.stream.BaseStream;

/**
 * Auto-generated superclass of {@link Employee.Builder}, derived from the API of {@link Employee}.
 */
abstract class Employee_Builder {

  /**
   * Creates a new builder using {@code value} as a template.
   *
   * <p>If {@code value} is a partial, the builder will return more partials.
   */
  public static Employee.Builder from(Employee value) {
    if (value instanceof Rebuildable) {
      return ((Rebuildable) value).toBuilder();
    } else {
      return new Employee.Builder().mergeFrom(value);
    }
  }

  private enum Property {
    NAME("name"),
    AGE("age"),
    DEPARTMENT("department"),
    EMAIL("email"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  private String name;
  private int age;
  private String department;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String nickname = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private Double salaryInUSD = null;
  private String email;
  private final ArrayList<Integer> nums = new ArrayList<>();
  private final LinkedHashSet<Integer> nums2 = new LinkedHashSet<>();
  private final LinkedHashMap<String, String> keyValueMap = new LinkedHashMap<>();
  private final LinkedHashMap<String, String> map2 = new LinkedHashMap<>();
  private final LinkedHashMap<String, String> map3 = new LinkedHashMap<>();
  private final EnumSet<Property> _unsetProperties = EnumSet.allOf(Property.class);

  /**
   * Sets the value to be returned by {@link Employee#name()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code name} is null
   */
  public Employee.Builder name(String name) {
    this.name = Objects.requireNonNull(name);
    _unsetProperties.remove(Property.NAME);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#name()} by applying {@code mapper} to it
   * and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapName(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return name(mapper.apply(name()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#name()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String name() {
    if (_unsetProperties.contains(Property.NAME)) {
      throw new IllegalStateException("name not set");
    }
    return name;
  }

  /**
   * Sets the value to be returned by {@link Employee#age()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder age(int age) {
    this.age = age;
    _unsetProperties.remove(Property.AGE);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#age()} by applying {@code mapper} to it
   * and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapAge(IntUnaryOperator mapper) {
    Objects.requireNonNull(mapper);
    return age(mapper.applyAsInt(age()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#age()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public int age() {
    if (_unsetProperties.contains(Property.AGE)) {
      throw new IllegalStateException("age not set");
    }
    return age;
  }

  /**
   * Sets the value to be returned by {@link Employee#department()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code department} is null
   */
  public Employee.Builder department(String department) {
    this.department = Objects.requireNonNull(department);
    _unsetProperties.remove(Property.DEPARTMENT);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#department()} by applying {@code mapper}
   * to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapDepartment(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return department(mapper.apply(department()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#department()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String department() {
    if (_unsetProperties.contains(Property.DEPARTMENT)) {
      throw new IllegalStateException("department not set");
    }
    return department;
  }

  /**
   * Sets the value to be returned by {@link Employee#nickname()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code nickname} is null
   */
  public Employee.Builder nickname(String nickname) {
    this.nickname = Objects.requireNonNull(nickname);
    return (Employee.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Employee#nickname()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder nickname(Optional<? extends String> nickname) {
    if (nickname.isPresent()) {
      return nickname(nickname.get());
    } else {
      return clearNickname();
    }
  }

  /**
   * Sets the value to be returned by {@link Employee#nickname()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder nullableNickname(String nickname) {
    if (nickname != null) {
      return nickname(nickname);
    } else {
      return clearNickname();
    }
  }

  /**
   * If the value to be returned by {@link Employee#nickname()} is present, replaces it by applying
   * {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Employee.Builder mapNickname(UnaryOperator<String> mapper) {
    return nickname(nickname().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Employee#nickname()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearNickname() {
    nickname = null;
    return (Employee.Builder) this;
  }

  /** Returns the value that will be returned by {@link Employee#nickname()}. */
  public Optional<String> nickname() {
    return Optional.ofNullable(nickname);
  }

  /**
   * Sets the value to be returned by {@link Employee#salaryInUSD()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder salaryInUSD(double salaryInUSD) {
    this.salaryInUSD = salaryInUSD;
    return (Employee.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Employee#salaryInUSD()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder salaryInUSD(Optional<? extends Double> salaryInUSD) {
    if (salaryInUSD.isPresent()) {
      return salaryInUSD(salaryInUSD.get());
    } else {
      return clearSalaryInUSD();
    }
  }

  /**
   * Sets the value to be returned by {@link Employee#salaryInUSD()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder nullableSalaryInUSD(Double salaryInUSD) {
    if (salaryInUSD != null) {
      return salaryInUSD(salaryInUSD);
    } else {
      return clearSalaryInUSD();
    }
  }

  /**
   * If the value to be returned by {@link Employee#salaryInUSD()} is present, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Employee.Builder mapSalaryInUSD(UnaryOperator<Double> mapper) {
    return salaryInUSD(salaryInUSD().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Employee#salaryInUSD()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearSalaryInUSD() {
    salaryInUSD = null;
    return (Employee.Builder) this;
  }

  /** Returns the value that will be returned by {@link Employee#salaryInUSD()}. */
  public Optional<Double> salaryInUSD() {
    return Optional.ofNullable(salaryInUSD);
  }

  /**
   * Sets the value to be returned by {@link Employee#email()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code email} is null
   */
  public Employee.Builder email(String email) {
    this.email = Objects.requireNonNull(email);
    _unsetProperties.remove(Property.EMAIL);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#email()} by applying {@code mapper} to it
   * and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapEmail(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return email(mapper.apply(email()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#email()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String email() {
    if (_unsetProperties.contains(Property.EMAIL)) {
      throw new IllegalStateException("email not set");
    }
    return email;
  }

  /**
   * Adds {@code element} to the list to be returned from {@link Employee#nums()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder addNums(int element) {
    nums.add(element);
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from {@link Employee#nums()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder addNums(int... elements) {
    nums.ensureCapacity(nums.size() + elements.length);
    for (int element : elements) {
      addNums(element);
    }
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from {@link Employee#nums()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllNums(Spliterator<? extends Integer> elements) {
    if ((elements.characteristics() & Spliterator.SIZED) != 0) {
      long elementsSize = elements.estimateSize();
      if (elementsSize > 0 && elementsSize <= Integer.MAX_VALUE) {
        nums.ensureCapacity(nums.size() + (int) elementsSize);
      }
    }
    elements.forEachRemaining(this::addNums);
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from {@link Employee#nums()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllNums(BaseStream<? extends Integer, ?> elements) {
    return addAllNums(elements.spliterator());
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from {@link Employee#nums()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllNums(Iterable<? extends Integer> elements) {
    return addAllNums(elements.spliterator());
  }

  /**
   * Applies {@code mutator} to the list to be returned from {@link Employee#nums()}.
   *
   * <p>This method mutates the list in-place. {@code mutator} is a void consumer, so any value
   * returned from a lambda will be ignored. Take care not to call pure functions, like {@link
   * Collection#stream()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mutator} is null
   */
  public Employee.Builder mutateNums(Consumer<? super List<Integer>> mutator) {
    // If addNums is overridden, this method will be updated to delegate to it
    mutator.accept(nums);
    return (Employee.Builder) this;
  }

  /**
   * Clears the list to be returned from {@link Employee#nums()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearNums() {
    nums.clear();
    return (Employee.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the list that will be returned by {@link Employee#nums()}.
   * Changes to this builder will be reflected in the view.
   */
  public List<Integer> nums() {
    return Collections.unmodifiableList(nums);
  }

  /**
   * Adds {@code element} to the set to be returned from {@link Employee#nums2()}. If the set
   * already contains {@code element}, then {@code addNums2} has no effect (only the previously
   * added element is retained).
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder addNums2(int element) {
    nums2.add(element);
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the set to be returned from {@link Employee#nums2()},
   * ignoring duplicate elements (only the first duplicate element is added).
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder addNums2(int... elements) {
    for (Integer element : elements) {
      addNums2(element);
    }
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the set to be returned from {@link Employee#nums2()},
   * ignoring duplicate elements (only the first duplicate element is added).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllNums2(Spliterator<? extends Integer> elements) {
    elements.forEachRemaining(this::addNums2);
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the set to be returned from {@link Employee#nums2()},
   * ignoring duplicate elements (only the first duplicate element is added).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllNums2(BaseStream<? extends Integer, ?> elements) {
    return addAllNums2(elements.spliterator());
  }

  /**
   * Adds each element of {@code elements} to the set to be returned from {@link Employee#nums2()},
   * ignoring duplicate elements (only the first duplicate element is added).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllNums2(Iterable<? extends Integer> elements) {
    elements.forEach(this::addNums2);
    return (Employee.Builder) this;
  }

  /**
   * Removes {@code element} from the set to be returned from {@link Employee#nums2()}. Does nothing
   * if {@code element} is not a member of the set.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder removeNums2(int element) {
    nums2.remove(element);
    return (Employee.Builder) this;
  }

  /**
   * Applies {@code mutator} to the set to be returned from {@link Employee#nums2()}.
   *
   * <p>This method mutates the set in-place. {@code mutator} is a void consumer, so any value
   * returned from a lambda will be ignored. Take care not to call pure functions, like {@link
   * Collection#stream()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mutator} is null
   */
  public Employee.Builder mutateNums2(Consumer<? super Set<Integer>> mutator) {
    // If addNums2 is overridden, this method will be updated to delegate to it
    mutator.accept(nums2);
    return (Employee.Builder) this;
  }

  /**
   * Clears the set to be returned from {@link Employee#nums2()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearNums2() {
    nums2.clear();
    return (Employee.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the set that will be returned by {@link Employee#nums2()}.
   * Changes to this builder will be reflected in the view.
   */
  public Set<Integer> nums2() {
    return Collections.unmodifiableSet(nums2);
  }

  /**
   * Associates {@code key} with {@code value} in the map to be returned from {@link
   * Employee#keyValueMap()}. If the map previously contained a mapping for the key, the old value
   * is replaced by the specified value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if either {@code key} or {@code value} are null
   */
  public Employee.Builder putKeyValueMap(String key, String value) {
    Objects.requireNonNull(key);
    Objects.requireNonNull(value);
    keyValueMap.put(key, value);
    return (Employee.Builder) this;
  }

  /**
   * Copies all of the mappings from {@code map} to the map to be returned from {@link
   * Employee#keyValueMap()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code map} is null or contains a null key or value
   */
  public Employee.Builder putAllKeyValueMap(Map<? extends String, ? extends String> map) {
    for (Map.Entry<? extends String, ? extends String> entry : map.entrySet()) {
      putKeyValueMap(entry.getKey(), entry.getValue());
    }
    return (Employee.Builder) this;
  }

  /**
   * Removes the mapping for {@code key} from the map to be returned from {@link
   * Employee#keyValueMap()}, if one is present.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code key} is null
   */
  public Employee.Builder removeKeyValueMap(String key) {
    Objects.requireNonNull(key);
    keyValueMap.remove(key);
    return (Employee.Builder) this;
  }

  /**
   * Invokes {@code mutator} with the map to be returned from {@link Employee#keyValueMap()}.
   *
   * <p>This method mutates the map in-place. {@code mutator} is a void consumer, so any value
   * returned from a lambda will be ignored. Take care not to call pure functions, like {@link
   * Collection#stream()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mutator} is null
   */
  public Employee.Builder mutateKeyValueMap(Consumer<? super Map<String, String>> mutator) {
    // If putKeyValueMap is overridden, this method will be updated to delegate to it
    mutator.accept(keyValueMap);
    return (Employee.Builder) this;
  }

  /**
   * Removes all of the mappings from the map to be returned from {@link Employee#keyValueMap()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearKeyValueMap() {
    keyValueMap.clear();
    return (Employee.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the map that will be returned by {@link
   * Employee#keyValueMap()}. Changes to this builder will be reflected in the view.
   */
  public Map<String, String> keyValueMap() {
    return Collections.unmodifiableMap(keyValueMap);
  }

  /**
   * Associates {@code key} with {@code value} in the map to be returned from {@link
   * Employee#map2()}. If the map previously contained a mapping for the key, the old value is
   * replaced by the specified value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if either {@code key} or {@code value} are null
   */
  public Employee.Builder putMap2(String key, String value) {
    Objects.requireNonNull(key);
    Objects.requireNonNull(value);
    map2.put(key, value);
    return (Employee.Builder) this;
  }

  /**
   * Copies all of the mappings from {@code map} to the map to be returned from {@link
   * Employee#map2()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code map} is null or contains a null key or value
   */
  public Employee.Builder putAllMap2(Map<? extends String, ? extends String> map) {
    for (Map.Entry<? extends String, ? extends String> entry : map.entrySet()) {
      putMap2(entry.getKey(), entry.getValue());
    }
    return (Employee.Builder) this;
  }

  /**
   * Removes the mapping for {@code key} from the map to be returned from {@link Employee#map2()},
   * if one is present.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code key} is null
   */
  public Employee.Builder removeMap2(String key) {
    Objects.requireNonNull(key);
    map2.remove(key);
    return (Employee.Builder) this;
  }

  /**
   * Invokes {@code mutator} with the map to be returned from {@link Employee#map2()}.
   *
   * <p>This method mutates the map in-place. {@code mutator} is a void consumer, so any value
   * returned from a lambda will be ignored. Take care not to call pure functions, like {@link
   * Collection#stream()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mutator} is null
   */
  public Employee.Builder mutateMap2(Consumer<? super Map<String, String>> mutator) {
    // If putMap2 is overridden, this method will be updated to delegate to it
    mutator.accept(map2);
    return (Employee.Builder) this;
  }

  /**
   * Removes all of the mappings from the map to be returned from {@link Employee#map2()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearMap2() {
    map2.clear();
    return (Employee.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the map that will be returned by {@link Employee#map2()}.
   * Changes to this builder will be reflected in the view.
   */
  public Map<String, String> map2() {
    return Collections.unmodifiableMap(map2);
  }

  /**
   * Associates {@code key} with {@code value} in the map to be returned from {@link
   * Employee#map3()}. If the map previously contained a mapping for the key, the old value is
   * replaced by the specified value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if either {@code key} or {@code value} are null
   */
  public Employee.Builder putMap3(String key, String value) {
    Objects.requireNonNull(key);
    Objects.requireNonNull(value);
    map3.put(key, value);
    return (Employee.Builder) this;
  }

  /**
   * Copies all of the mappings from {@code map} to the map to be returned from {@link
   * Employee#map3()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code map} is null or contains a null key or value
   */
  public Employee.Builder putAllMap3(Map<? extends String, ? extends String> map) {
    for (Map.Entry<? extends String, ? extends String> entry : map.entrySet()) {
      putMap3(entry.getKey(), entry.getValue());
    }
    return (Employee.Builder) this;
  }

  /**
   * Removes the mapping for {@code key} from the map to be returned from {@link Employee#map3()},
   * if one is present.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code key} is null
   */
  public Employee.Builder removeMap3(String key) {
    Objects.requireNonNull(key);
    map3.remove(key);
    return (Employee.Builder) this;
  }

  /**
   * Invokes {@code mutator} with the map to be returned from {@link Employee#map3()}.
   *
   * <p>This method mutates the map in-place. {@code mutator} is a void consumer, so any value
   * returned from a lambda will be ignored. Take care not to call pure functions, like {@link
   * Collection#stream()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mutator} is null
   */
  public Employee.Builder mutateMap3(Consumer<? super Map<String, String>> mutator) {
    // If putMap3 is overridden, this method will be updated to delegate to it
    mutator.accept(map3);
    return (Employee.Builder) this;
  }

  /**
   * Removes all of the mappings from the map to be returned from {@link Employee#map3()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearMap3() {
    map3.clear();
    return (Employee.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the map that will be returned by {@link Employee#map3()}.
   * Changes to this builder will be reflected in the view.
   */
  public Map<String, String> map3() {
    return Collections.unmodifiableMap(map3);
  }

  /**
   * Copies values from {@code value}, appending to collections, and skipping empty optionals.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder mergeFrom(Employee value) {
    Employee_Builder defaults = new Employee.Builder();
    if (defaults._unsetProperties.contains(Property.NAME)
        || !Objects.equals(value.name(), defaults.name())) {
      name(value.name());
    }
    if (defaults._unsetProperties.contains(Property.AGE) || value.age() != defaults.age()) {
      age(value.age());
    }
    if (defaults._unsetProperties.contains(Property.DEPARTMENT)
        || !Objects.equals(value.department(), defaults.department())) {
      department(value.department());
    }
    value.nickname().ifPresent(this::nickname);
    value.salaryInUSD().ifPresent(this::salaryInUSD);
    if (defaults._unsetProperties.contains(Property.EMAIL)
        || !Objects.equals(value.email(), defaults.email())) {
      email(value.email());
    }
    addAllNums(value.nums());
    addAllNums2(value.nums2());
    putAllKeyValueMap(value.keyValueMap());
    putAllMap2(value.map2());
    putAllMap3(value.map3());
    return (Employee.Builder) this;
  }

  /**
   * Copies values from {@code template}, appending to collections, and skipping empty optionals and
   * unset properties.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder mergeFrom(Employee.Builder template) {
    // Upcast to access private fields; otherwise, oddly, we get an access violation.
    Employee_Builder base = template;
    Employee_Builder defaults = new Employee.Builder();
    if (!base._unsetProperties.contains(Property.NAME)
        && (defaults._unsetProperties.contains(Property.NAME)
            || !Objects.equals(template.name(), defaults.name()))) {
      name(template.name());
    }
    if (!base._unsetProperties.contains(Property.AGE)
        && (defaults._unsetProperties.contains(Property.AGE) || template.age() != defaults.age())) {
      age(template.age());
    }
    if (!base._unsetProperties.contains(Property.DEPARTMENT)
        && (defaults._unsetProperties.contains(Property.DEPARTMENT)
            || !Objects.equals(template.department(), defaults.department()))) {
      department(template.department());
    }
    template.nickname().ifPresent(this::nickname);
    template.salaryInUSD().ifPresent(this::salaryInUSD);
    if (!base._unsetProperties.contains(Property.EMAIL)
        && (defaults._unsetProperties.contains(Property.EMAIL)
            || !Objects.equals(template.email(), defaults.email()))) {
      email(template.email());
    }
    addAllNums(base.nums);
    addAllNums2(base.nums2);
    putAllKeyValueMap(base.keyValueMap);
    putAllMap2(base.map2);
    putAllMap3(base.map3);
    return (Employee.Builder) this;
  }

  /**
   * Resets the state of this builder.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clear() {
    Employee_Builder defaults = new Employee.Builder();
    name = defaults.name;
    age = defaults.age;
    department = defaults.department;
    nickname = defaults.nickname;
    salaryInUSD = defaults.salaryInUSD;
    email = defaults.email;
    clearNums();
    clearNums2();
    keyValueMap.clear();
    map2.clear();
    map3.clear();
    _unsetProperties.clear();
    _unsetProperties.addAll(defaults._unsetProperties);
    return (Employee.Builder) this;
  }

  /**
   * Returns a newly-created {@link Employee} based on the contents of this {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public Employee build() {
    if (!_unsetProperties.isEmpty()) {
      throw new IllegalStateException("Not set: " + _unsetProperties);
    }
    return new Value(this);
  }

  /**
   * Returns a newly-created partial {@link Employee} for use in unit tests. State checking will not
   * be performed. Unset properties will throw an {@link UnsupportedOperationException} when
   * accessed via the partial object.
   *
   * <p>The builder returned by {@link Employee.Builder#from(Employee)} will propagate the partial
   * status of its input, overriding {@link Employee.Builder#build() build()} to return another
   * partial. This allows for robust tests of modify-rebuild code.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  public Employee buildPartial() {
    return new Partial(this);
  }

  private abstract static class Rebuildable implements Employee {
    public abstract Builder toBuilder();
  }

  private static final class Value extends Rebuildable {
    private final String name;
    private final int age;
    private final String department;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String nickname;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final Double salaryInUSD;
    private final String email;
    private final List<Integer> nums;
    private final Set<Integer> nums2;
    private final Map<String, String> keyValueMap;
    private final Map<String, String> map2;
    private final Map<String, String> map3;

    private Value(Employee_Builder builder) {
      this.name = builder.name;
      this.age = builder.age;
      this.department = builder.department;
      this.nickname = builder.nickname;
      this.salaryInUSD = builder.salaryInUSD;
      this.email = builder.email;
      this.nums = immutableList(builder.nums);
      this.nums2 = immutableSet(builder.nums2);
      this.keyValueMap = immutableMap(builder.keyValueMap);
      this.map2 = immutableMap(builder.map2);
      this.map3 = immutableMap(builder.map3);
    }

    @Override
    public String name() {
      return name;
    }

    @Override
    public int age() {
      return age;
    }

    @Override
    public String department() {
      return department;
    }

    @Override
    public Optional<String> nickname() {
      return Optional.ofNullable(nickname);
    }

    @Override
    public Optional<Double> salaryInUSD() {
      return Optional.ofNullable(salaryInUSD);
    }

    @Override
    public String email() {
      return email;
    }

    @Override
    public List<Integer> nums() {
      return nums;
    }

    @Override
    public Set<Integer> nums2() {
      return nums2;
    }

    @Override
    public Map<String, String> keyValueMap() {
      return keyValueMap;
    }

    @Override
    public Map<String, String> map2() {
      return map2;
    }

    @Override
    public Map<String, String> map3() {
      return map3;
    }

    @Override
    public Builder toBuilder() {
      Employee_Builder builder = new Builder();
      builder.name = name;
      builder.age = age;
      builder.department = department;
      builder.nickname = nickname;
      builder.salaryInUSD = salaryInUSD;
      builder.email = email;
      builder.nums.addAll(nums);
      builder.nums2.addAll(nums2);
      builder.keyValueMap.putAll(keyValueMap);
      builder.map2.putAll(map2);
      builder.map3.putAll(map3);
      builder._unsetProperties.clear();
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Value)) {
        return false;
      }
      Value other = (Value) obj;
      return Objects.equals(name, other.name)
          && age == other.age
          && Objects.equals(department, other.department)
          && Objects.equals(nickname, other.nickname)
          && Objects.equals(salaryInUSD, other.salaryInUSD)
          && Objects.equals(email, other.email)
          && Objects.equals(nums, other.nums)
          && Objects.equals(nums2, other.nums2)
          && Objects.equals(keyValueMap, other.keyValueMap)
          && Objects.equals(map2, other.map2)
          && Objects.equals(map3, other.map3);
    }

    @Override
    public int hashCode() {
      return Objects.hash(
          name,
          age,
          department,
          nickname,
          salaryInUSD,
          email,
          nums,
          nums2,
          keyValueMap,
          map2,
          map3);
    }

    @Override
    public String toString() {
      StringBuilder result =
          new StringBuilder("Employee{name=")
              .append(name)
              .append(", age=")
              .append(age)
              .append(", department=")
              .append(department);
      if (nickname != null) {
        result.append(", nickname=").append(nickname);
      }
      if (salaryInUSD != null) {
        result.append(", salaryInUSD=").append(salaryInUSD);
      }
      return result
          .append(", email=")
          .append(email)
          .append(", nums=")
          .append(nums)
          .append(", nums2=")
          .append(nums2)
          .append(", keyValueMap=")
          .append(keyValueMap)
          .append(", map2=")
          .append(map2)
          .append(", map3=")
          .append(map3)
          .append("}")
          .toString();
    }
  }

  private static final class Partial extends Rebuildable {
    private final String name;
    private final int age;
    private final String department;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String nickname;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final Double salaryInUSD;
    private final String email;
    private final List<Integer> nums;
    private final Set<Integer> nums2;
    private final Map<String, String> keyValueMap;
    private final Map<String, String> map2;
    private final Map<String, String> map3;
    private final EnumSet<Property> _unsetProperties;

    Partial(Employee_Builder builder) {
      this.name = builder.name;
      this.age = builder.age;
      this.department = builder.department;
      this.nickname = builder.nickname;
      this.salaryInUSD = builder.salaryInUSD;
      this.email = builder.email;
      this.nums = immutableList(builder.nums);
      this.nums2 = immutableSet(builder.nums2);
      this.keyValueMap = immutableMap(builder.keyValueMap);
      this.map2 = immutableMap(builder.map2);
      this.map3 = immutableMap(builder.map3);
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    public String name() {
      if (_unsetProperties.contains(Property.NAME)) {
        throw new UnsupportedOperationException("name not set");
      }
      return name;
    }

    @Override
    public int age() {
      if (_unsetProperties.contains(Property.AGE)) {
        throw new UnsupportedOperationException("age not set");
      }
      return age;
    }

    @Override
    public String department() {
      if (_unsetProperties.contains(Property.DEPARTMENT)) {
        throw new UnsupportedOperationException("department not set");
      }
      return department;
    }

    @Override
    public Optional<String> nickname() {
      return Optional.ofNullable(nickname);
    }

    @Override
    public Optional<Double> salaryInUSD() {
      return Optional.ofNullable(salaryInUSD);
    }

    @Override
    public String email() {
      if (_unsetProperties.contains(Property.EMAIL)) {
        throw new UnsupportedOperationException("email not set");
      }
      return email;
    }

    @Override
    public List<Integer> nums() {
      return nums;
    }

    @Override
    public Set<Integer> nums2() {
      return nums2;
    }

    @Override
    public Map<String, String> keyValueMap() {
      return keyValueMap;
    }

    @Override
    public Map<String, String> map2() {
      return map2;
    }

    @Override
    public Map<String, String> map3() {
      return map3;
    }

    private static class PartialBuilder extends Builder {
      @Override
      public Employee build() {
        return buildPartial();
      }
    }

    @Override
    public Builder toBuilder() {
      Employee_Builder builder = new PartialBuilder();
      builder.name = name;
      builder.age = age;
      builder.department = department;
      builder.nickname = nickname;
      builder.salaryInUSD = salaryInUSD;
      builder.email = email;
      builder.nums.addAll(nums);
      builder.nums2.addAll(nums2);
      builder.keyValueMap.putAll(keyValueMap);
      builder.map2.putAll(map2);
      builder.map3.putAll(map3);
      builder._unsetProperties.clear();
      builder._unsetProperties.addAll(_unsetProperties);
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Partial)) {
        return false;
      }
      Partial other = (Partial) obj;
      return Objects.equals(name, other.name)
          && age == other.age
          && Objects.equals(department, other.department)
          && Objects.equals(nickname, other.nickname)
          && Objects.equals(salaryInUSD, other.salaryInUSD)
          && Objects.equals(email, other.email)
          && Objects.equals(nums, other.nums)
          && Objects.equals(nums2, other.nums2)
          && Objects.equals(keyValueMap, other.keyValueMap)
          && Objects.equals(map2, other.map2)
          && Objects.equals(map3, other.map3)
          && Objects.equals(_unsetProperties, other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Objects.hash(
          name,
          age,
          department,
          nickname,
          salaryInUSD,
          email,
          nums,
          nums2,
          keyValueMap,
          map2,
          map3,
          _unsetProperties);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("partial Employee{");
      if (!_unsetProperties.contains(Property.NAME)) {
        result.append("name=").append(name).append(", ");
      }
      if (!_unsetProperties.contains(Property.AGE)) {
        result.append("age=").append(age).append(", ");
      }
      if (!_unsetProperties.contains(Property.DEPARTMENT)) {
        result.append("department=").append(department).append(", ");
      }
      if (nickname != null) {
        result.append("nickname=").append(nickname).append(", ");
      }
      if (salaryInUSD != null) {
        result.append("salaryInUSD=").append(salaryInUSD).append(", ");
      }
      if (!_unsetProperties.contains(Property.EMAIL)) {
        result.append("email=").append(email).append(", ");
      }
      return result
          .append("nums=")
          .append(nums)
          .append(", nums2=")
          .append(nums2)
          .append(", keyValueMap=")
          .append(keyValueMap)
          .append(", map2=")
          .append(map2)
          .append(", map3=")
          .append(map3)
          .append("}")
          .toString();
    }
  }

  @SuppressWarnings("unchecked")
  private static <E> List<E> immutableList(List<E> elements) {
    switch (elements.size()) {
      case 0:
        return Collections.emptyList();
      case 1:
        return Collections.singletonList(elements.get(0));
      default:
        return (List<E>) (List<?>) Collections.unmodifiableList(Arrays.asList(elements.toArray()));
    }
  }

  private static <K, V> Map<K, V> immutableMap(Map<K, V> entries) {
    switch (entries.size()) {
      case 0:
        return Collections.emptyMap();
      case 1:
        Map.Entry<K, V> entry = entries.entrySet().iterator().next();
        return Collections.singletonMap(entry.getKey(), entry.getValue());
      default:
        return Collections.unmodifiableMap(new LinkedHashMap<>(entries));
    }
  }

  private static <E> Set<E> immutableSet(Set<E> elements) {
    switch (elements.size()) {
      case 0:
        return Collections.emptySet();
      case 1:
        return Collections.singleton(elements.iterator().next());
      default:
        return Collections.unmodifiableSet(new LinkedHashSet<>(elements));
    }
  }
}
